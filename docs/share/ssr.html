<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>快陪练技术博客</title>
    <meta name="description" content="陪孩子快乐练琴，成就更美好的未来！">
    <link rel="icon" href="favicon.ico">
  <meta name="theme-color" content="#3eaf7c">
    
    <link rel="preload" href="/blog/assets/css/0.styles.1274d17f.css" as="style"><link rel="preload" href="/blog/assets/js/app.13032188.js" as="script"><link rel="preload" href="/blog/assets/js/2.63f30d76.js" as="script"><link rel="preload" href="/blog/assets/js/22.52f1fa96.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.4d0f6ad7.js"><link rel="prefetch" href="/blog/assets/js/11.ea654b9e.js"><link rel="prefetch" href="/blog/assets/js/12.5950da64.js"><link rel="prefetch" href="/blog/assets/js/13.e6ba022d.js"><link rel="prefetch" href="/blog/assets/js/14.79f2fdf1.js"><link rel="prefetch" href="/blog/assets/js/15.6bbe8233.js"><link rel="prefetch" href="/blog/assets/js/16.f911afaf.js"><link rel="prefetch" href="/blog/assets/js/17.6262681f.js"><link rel="prefetch" href="/blog/assets/js/18.49ba5e8c.js"><link rel="prefetch" href="/blog/assets/js/19.1824a481.js"><link rel="prefetch" href="/blog/assets/js/20.d8365d52.js"><link rel="prefetch" href="/blog/assets/js/21.5a0b7b4d.js"><link rel="prefetch" href="/blog/assets/js/23.9f5bf9e9.js"><link rel="prefetch" href="/blog/assets/js/24.47754074.js"><link rel="prefetch" href="/blog/assets/js/25.913eea8a.js"><link rel="prefetch" href="/blog/assets/js/26.311bc85e.js"><link rel="prefetch" href="/blog/assets/js/3.7d9cf371.js"><link rel="prefetch" href="/blog/assets/js/4.e2e0255b.js"><link rel="prefetch" href="/blog/assets/js/5.3bf4e290.js"><link rel="prefetch" href="/blog/assets/js/6.82e633a8.js"><link rel="prefetch" href="/blog/assets/js/7.de7f86a6.js"><link rel="prefetch" href="/blog/assets/js/8.369c3623.js"><link rel="prefetch" href="/blog/assets/js/9.11933db1.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.1274d17f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">快陪练技术博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/job/" class="nav-link">广纳英才</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">实战分享</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/share/flutter.html" class="nav-link">flutter混合开发</a></li><li class="dropdown-item"><!----> <a href="/blog/share/flutter_web.html" class="nav-link">flutter_web体验</a></li><li class="dropdown-item"><!----> <a href="/blog/share/ssr.html" class="nav-link router-link-exact-active router-link-active">vue服务端渲染</a></li><li class="dropdown-item"><!----> <a href="/blog/share/mp.html" class="nav-link">小程序开发总结</a></li><li class="dropdown-item"><!----> <a href="/blog/share/iris.html" class="nav-link">go+vue前后端分离实战</a></li><li class="dropdown-item"><!----> <a href="/blog/share/uni.html" class="nav-link">uni-app多端开发回顾</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">大前端教程</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/fe/vue.html" class="nav-link">前端进阶</a></li><li class="dropdown-item"><!----> <a href="/blog/js/1.html" class="nav-link">JS入门</a></li><li class="dropdown-item"><!----> <a href="/blog/url/fe.html" class="nav-link">常用网址</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">后端教程</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/url/be.html" class="nav-link">常用网址</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/job/" class="nav-link">广纳英才</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">实战分享</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/share/flutter.html" class="nav-link">flutter混合开发</a></li><li class="dropdown-item"><!----> <a href="/blog/share/flutter_web.html" class="nav-link">flutter_web体验</a></li><li class="dropdown-item"><!----> <a href="/blog/share/ssr.html" class="nav-link router-link-exact-active router-link-active">vue服务端渲染</a></li><li class="dropdown-item"><!----> <a href="/blog/share/mp.html" class="nav-link">小程序开发总结</a></li><li class="dropdown-item"><!----> <a href="/blog/share/iris.html" class="nav-link">go+vue前后端分离实战</a></li><li class="dropdown-item"><!----> <a href="/blog/share/uni.html" class="nav-link">uni-app多端开发回顾</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">大前端教程</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/fe/vue.html" class="nav-link">前端进阶</a></li><li class="dropdown-item"><!----> <a href="/blog/js/1.html" class="nav-link">JS入门</a></li><li class="dropdown-item"><!----> <a href="/blog/url/fe.html" class="nav-link">常用网址</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">后端教程</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/url/be.html" class="nav-link">常用网址</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span></span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/share/ssr.html#方案调研" class="sidebar-link">方案调研</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/share/ssr.html#什么是服务器端渲染-ssr-？" class="sidebar-link">什么是服务器端渲染 (SSR)？</a></li><li class="sidebar-sub-header"><a href="/blog/share/ssr.html#服务器端渲染的利弊" class="sidebar-link">服务器端渲染的利弊</a></li></ul></li><li><a href="/blog/share/ssr.html#原理分析" class="sidebar-link">原理分析</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/share/ssr.html#如何实现及源码分析" class="sidebar-link">如何实现及源码分析</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/share/ssr.html#生成bundle" class="sidebar-link">生成bundle</a></li><li class="sidebar-sub-header"><a href="/blog/share/ssr.html#createbundlerenderer" class="sidebar-link">createBundleRenderer</a></li><li class="sidebar-sub-header"><a href="/blog/share/ssr.html#rendertostring" class="sidebar-link">renderToString</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>最新我们团队使用vue技术栈对官网进行了重构和优化，经过调研，在架构上前后端分离，由于有SEO的要求，所以需要做服务端渲染，本文将分享一下我们实战的过程。</p> <h2 id="方案调研"><a href="#方案调研" aria-hidden="true" class="header-anchor">#</a> 方案调研</h2> <p>在接到了重构和优化的需求后，我们首先需要去做技术调研，因为vue做服务端渲染已经很成熟了，并且我们团队就基本都用过vue，所以我们优先考虑使用vue技术栈进行重构。</p> <p>实现业务功能和页面并不难，难点在于做服务端渲染，所以我们需要通过官网https://ssr.vuejs.org/zh/的Vue.js 服务器端渲染指南 和 网上各种实战分享了解各种必备知识。</p> <h3 id="什么是服务器端渲染-ssr-？"><a href="#什么是服务器端渲染-ssr-？" aria-hidden="true" class="header-anchor">#</a> 什么是服务器端渲染 (SSR)？</h3> <p>早在SPA (Single Page Application 单页应用) 出现之前，所有的网页就是在服务端渲染的，服务器接收到客户端请求后，将数据和模板拼接成完整的html 文本到客户端。</p> <p>随着 JS 的发展, 特别是支持SPA 的react和vue框架的出现, 呈现页面完全静态化, 动态内容交给前端(Js)渲染, 服务器只提供数据，前端还能控制页面的路由跳转。</p> <p>对于vue的项目，服务端渲染指的是，服务器端将Vue的页面和对应的业务数据，在服务器直接完全渲染成html字符串后，再发送至浏览器, 最后在浏览器中混合为可交互的应用程序。</p> <h3 id="服务器端渲染的利弊"><a href="#服务器端渲染的利弊" aria-hidden="true" class="header-anchor">#</a> 服务器端渲染的利弊</h3> <p>与传统 SPA 相比，采用服务端渲染后，用户能够更快的看到页面内容, 同时也有利于爬虫抓取(SEO)。</p> <p>同时服务端渲染，也需要 node 服务器, 需要耗费性能, 还需要做好缓存和优化, 相当于用空间换时间，全站 ssr 明显不可取, 现在流行较多的是首屏 ssr, 甚至首屏部分 ssr。</p> <h2 id="原理分析"><a href="#原理分析" aria-hidden="true" class="header-anchor">#</a> 原理分析</h2> <p>先看一张Vue官网的服务端渲染示意图：
<img src="/blog/img/ssr.png" alt="原理图.png"></p> <p>从图上可以看出，ssr 有两个入口文件，client.js 和 server.js， 都包含了应用代码，webpack 通过两个入口文件分别打包成给服务端用的 server bundle 和给客户端用的 client bundle。</p> <p>当服务器接收到了来自客户端的请求之后，会创建一个渲染器 bundleRenderer，这个 bundleRenderer 会读取上面生成的 server bundle 文件，并且执行它的代码， 然后发送一个生成好的 html 到浏览器。</p> <p>等到客户端加载了 client bundle 之后，会和服务端生成的DOM 进行 Hydration(判断这个DOM 和自己即将生成的DOM 是否相同，如果相同就将客户端的vue实例挂载到这个DOM上， 否则会提示警告)。</p> <h2 id="如何实现及源码分析"><a href="#如何实现及源码分析" aria-hidden="true" class="header-anchor">#</a> 如何实现及源码分析</h2> <p>不管是参照vue官方的ssr教程从头配置，还是使用第三方的脚手架nuxt.js自动配置，都需要使用nodejs作为服务器渲染打包好的bundle，同时也需要在部署前通过入口文件生成对应的bundle。</p> <h3 id="生成bundle"><a href="#生成bundle" aria-hidden="true" class="header-anchor">#</a> 生成bundle</h3> <ul><li>对于不同端的打包，需要使用对应的webpack插件配置，其中打包client bundle时为：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>const VueSSRClientPlugin = require('vue-server-renderer/client-plugin');
</code></pre></div><p>client-plugin的内容为：</p> <div class="language- extra-class"><pre class="language-text"><code>var onEmit = function (compiler, name, hook) {
  if (compiler.hooks) {
    compiler.hooks.emit.tapAsync(name, hook);
  } else {
    compiler.plugin('emit', hook);     // Webpack &lt; 4.0.0
  }
};
var VueSSRClientPlugin = function VueSSRClientPlugin (options) {
  if ( options === void 0 ) options = {};
  this.options = Object.assign({
    filename: 'vue-ssr-client-manifest.json'
  }, options);
};

VueSSRClientPlugin.prototype.apply = function apply (compiler) {
  var this$1 = this;
  onEmit(compiler, 'vue-client-plugin', function (compilation, cb) {
    var stats = compilation.getStats().toJson();

    var allFiles = uniq(stats.assets
      .map(function (a) { return a.name; }));

    var initialFiles = uniq(Object.keys(stats.entrypoints)
      .map(function (name) { return stats.entrypoints[name].assets; })
      .reduce(function (assets, all) { return all.concat(assets); }, [])
      .filter(function (file) { return isJS(file) || isCSS(file); }));

    var asyncFiles = allFiles
      .filter(function (file) { return isJS(file) || isCSS(file); })
      .filter(function (file) { return initialFiles.indexOf(file) &lt; 0; });

    var manifest = {
      publicPath: stats.publicPath,
      all: allFiles,
      initial: initialFiles,
      async: asyncFiles,
      modules: { /* [identifier: string]: Array&lt;index: number&gt; */ }
    };

    var assetModules = stats.modules.filter(function (m) { return m.assets.length; });
    var fileToIndex = function (file) { return manifest.all.indexOf(file); };
    stats.modules.forEach(function (m) {
      // ignore modules duplicated in multiple chunks
      if (m.chunks.length === 1) {
        var cid = m.chunks[0];
        var chunk = stats.chunks.find(function (c) { return c.id === cid; });
        if (!chunk || !chunk.files) {
          return
        }
        var id = m.identifier.replace(/\s\w+$/, ''); // remove appended hash
        var files = manifest.modules[hash(id)] = chunk.files.map(fileToIndex);
        // find all asset modules associated with the same chunk
        assetModules.forEach(function (m) {
          if (m.chunks.some(function (id) { return id === cid; })) {
            files.push.apply(files, m.assets.map(fileToIndex));
          }
        });
      }
    });

    var json = JSON.stringify(manifest, null, 2);
    compilation.assets[this$1.options.filename] = {
      source: function () { return json; },
      size: function () { return json.length; }
    };
    cb();
  });
};
module.exports = VueSSRClientPlugin;
</code></pre></div><p>而打包server bundle时为：</p> <div class="language- extra-class"><pre class="language-text"><code>const VueSSRServerPlugin = require('vue-server-renderer/server-plugin')
</code></pre></div><p>server-plugin的内容为：</p> <div class="language- extra-class"><pre class="language-text"><code>var onEmit = function (compiler, name, hook) {
  if (compiler.hooks) {
    compiler.hooks.emit.tapAsync(name, hook);
  } else {
    compiler.plugin('emit', hook); // Webpack &lt; 4.0.0
  }
};

var VueSSRServerPlugin = function VueSSRServerPlugin (options) {
  if ( options === void 0 ) options = {};

  this.options = Object.assign({
    filename: 'vue-ssr-server-bundle.json'
  }, options);
};

VueSSRServerPlugin.prototype.apply = function apply (compiler) {
  var this$1 = this;
  validate(compiler); // client插件没有

  onEmit(compiler, 'vue-server-plugin', function (compilation, cb) {
    var stats = compilation.getStats().toJson();
    var entryName = Object.keys(stats.entrypoints)[0];
    var entryInfo = stats.entrypoints[entryName];

    if (!entryInfo) {
      // #5553
      return cb()
    }

    var entryAssets = entryInfo.assets.filter(isJS);

    if (entryAssets.length &gt; 1) {
      throw new Error(
        &quot;Server-side bundle should have one single entry file. &quot; +
        &quot;Avoid using CommonsChunkPlugin in the server config.&quot;
      )
    }

    var entry = entryAssets[0];
    if (!entry || typeof entry !== 'string') {
      throw new Error(
        (&quot;Entry \&quot;&quot; + entryName + &quot;\&quot; not found. Did you specify the correct entry option?&quot;)
      )
    }

    var bundle = {
      entry: entry,
      files: {},
      maps: {}
    };

    stats.assets.forEach(function (asset) {
      if (isJS(asset.name)) {
        bundle.files[asset.name] = compilation.assets[asset.name].source();
      } else if (asset.name.match(/\.js\.map$/)) {
        bundle.maps[asset.name.replace(/\.map$/, '')] = JSON.parse(compilation.assets[asset.name].source());
      }
      // do not emit anything else for server
      delete compilation.assets[asset.name];
    });

    var json = JSON.stringify(bundle, null, 2);
    var filename = this$1.options.filename;

    compilation.assets[filename] = {
      source: function () { return json; },
      size: function () { return json.length; }
    };

    cb();
  });
};

module.exports = VueSSRServerPlugin;
</code></pre></div><p>可以看到 sever-plugin主要多了：</p> <div class="language- extra-class"><pre class="language-text"><code>var validate = function (compiler) {
  if (compiler.options.target !== 'node') {
    warn('webpack config `target` should be &quot;node&quot;.');
  }

  if (compiler.options.output &amp;&amp; compiler.options.output.libraryTarget !== 'commonjs2') {
    warn('webpack config `output.libraryTarget` should be &quot;commonjs2&quot;.');
  }

  if (!compiler.options.externals) {
    tip(
      'It is recommended to externalize dependencies in the server build for ' +
      'better build performance.'
    );
  }
};
</code></pre></div><h3 id="createbundlerenderer"><a href="#createbundlerenderer" aria-hidden="true" class="header-anchor">#</a> createBundleRenderer</h3> <div class="language- extra-class"><pre class="language-text"><code>const { createBundleRenderer } = require('vue-server-renderer');

const createRenderer = (bundle, opts = {}) =&gt; createBundleRenderer(
  bundle,
  Object.assign(opts, {
    basedir: resolve('./dist'),
    template: fs.readFileSync(templatePath, 'utf-8'),
    runInNewContext: false,
  }),
);

(ctx.body = await renderer.renderToString(context));
</code></pre></div><h3 id="rendertostring"><a href="#rendertostring" aria-hidden="true" class="header-anchor">#</a> renderToString</h3> <div class="language- extra-class"><pre class="language-text"><code>    renderToString: function renderToString (
      component,
      context,
      cb
    ) {
      var assign;

      if (typeof context === 'function') {
        cb = context;
        context = {};
      }
      if (context) {
        templateRenderer.bindRenderFns(context);
      }

      // no callback, return Promise
      var promise;
      if (!cb) {
        ((assign = createPromiseCallback(), promise = assign.promise, cb = assign.cb));
      }

      var result = '';
      var write = createWriteFunction(function (text) {
        result += text;
        return false
      }, cb);
      try {
        render(component, write, context, function (err) {
          if (err) {
            return cb(err)
          }
          if (context &amp;&amp; context.rendered) {
            context.rendered(context);
          }
          if (template) {
            try {
              var res = templateRenderer.render(result, context);
              if (typeof res !== 'string') {
                // function template returning promise
                res
                  .then(function (html) { return cb(null, html); })
                  .catch(cb);
              } else {
                cb(null, res);
              }
            } catch (e) {
              cb(e);
            }
          } else {
            cb(null, result);
          }
        });
      } catch (e) {
        cb(e);
      }

      return promise
    },
</code></pre></div><p>可以看到，vue实现服务端渲染主要是依靠vue-server-renderer，打包时用插件生成bundle，然后部署时提供createBundleRenderer处理页面请求，使用renderToString做服务端渲染。</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.13032188.js" defer></script><script src="/blog/assets/js/2.63f30d76.js" defer></script><script src="/blog/assets/js/22.52f1fa96.js" defer></script>
  </body>
</html>
