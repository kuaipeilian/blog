<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>VueRouter 源码 | 快陪练技术博客</title>
    <meta name="description" content="陪孩子快乐练琴，成就更美好的未来！">
    <link rel="icon" href="favicon.ico">
  <meta name="theme-color" content="#3eaf7c">
    
    <link rel="preload" href="/blog/assets/css/0.styles.1274d17f.css" as="style"><link rel="preload" href="/blog/assets/js/app.63c679db.js" as="script"><link rel="preload" href="/blog/assets/js/2.2658334b.js" as="script"><link rel="preload" href="/blog/assets/js/6.d0a4dcb1.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.f66540db.js"><link rel="prefetch" href="/blog/assets/js/11.c68dfc3e.js"><link rel="prefetch" href="/blog/assets/js/12.6ff268b2.js"><link rel="prefetch" href="/blog/assets/js/13.eef96997.js"><link rel="prefetch" href="/blog/assets/js/14.152b0962.js"><link rel="prefetch" href="/blog/assets/js/15.d6b5954c.js"><link rel="prefetch" href="/blog/assets/js/16.6958e89d.js"><link rel="prefetch" href="/blog/assets/js/17.bc68c433.js"><link rel="prefetch" href="/blog/assets/js/18.681ccb12.js"><link rel="prefetch" href="/blog/assets/js/3.1e54474f.js"><link rel="prefetch" href="/blog/assets/js/4.e2e0255b.js"><link rel="prefetch" href="/blog/assets/js/5.d18986a7.js"><link rel="prefetch" href="/blog/assets/js/7.7b17f9f8.js"><link rel="prefetch" href="/blog/assets/js/8.7a655855.js"><link rel="prefetch" href="/blog/assets/js/9.787f73ee.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.1274d17f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">快陪练技术博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/job/" class="nav-link">广纳英才</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">实战分享</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/share/flutter.html" class="nav-link">flutter混合开发</a></li><li class="dropdown-item"><!----> <a href="/blog/share/ssr.html" class="nav-link">vue服务端渲染</a></li><li class="dropdown-item"><!----> <a href="/blog/share/mp.html" class="nav-link">小程序开发总结</a></li></ul></div></div><div class="nav-item"><a href="/blog/fe/linux.html" class="nav-link">大前端教程</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/job/" class="nav-link">广纳英才</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">实战分享</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/share/flutter.html" class="nav-link">flutter混合开发</a></li><li class="dropdown-item"><!----> <a href="/blog/share/ssr.html" class="nav-link">vue服务端渲染</a></li><li class="dropdown-item"><!----> <a href="/blog/share/mp.html" class="nav-link">小程序开发总结</a></li></ul></div></div><div class="nav-item"><a href="/blog/fe/linux.html" class="nav-link">大前端教程</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>大前端教程</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/fe/vue.html" class="sidebar-link">vue源码分析</a></li><li><a href="/blog/fe/VueRouter.html" class="active sidebar-link">VueRouter 源码</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/fe/VueRouter.html#如何使用" class="sidebar-link">如何使用</a></li><li class="sidebar-sub-header"><a href="/blog/fe/VueRouter.html#vue-router-的入口" class="sidebar-link">Vue-Router 的入口</a></li><li class="sidebar-sub-header"><a href="/blog/fe/VueRouter.html#vuerouter-对象" class="sidebar-link">VueRouter 对象</a></li></ul></li><li><a href="/blog/fe/vuex.html" class="sidebar-link">Vuex源码分析</a></li><li><a href="/blog/fe/linux.html" class="sidebar-link">Linux 入门</a></li><li><a href="/blog/fe/vscode.html" class="sidebar-link">推荐 vscode</a></li><li><a href="/blog/fe/node.html" class="sidebar-link">关于nodejs</a></li><li><a href="/blog/fe/code.html" class="sidebar-link">代码规范</a></li><li><a href="/blog/fe/suanfa.html" class="sidebar-link">常见算法</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vuerouter-源码"><a href="#vuerouter-源码" aria-hidden="true" class="header-anchor">#</a> VueRouter 源码</h1> <p>路由的作用就是根据不同的路径映射到不同的视图，Vue 是一个渐进式 JavaScript 框架，本身的核心是解决视图渲染的问题，其它的能力就通过插件的方式来解决。</p> <h2 id="如何使用"><a href="#如何使用" aria-hidden="true" class="header-anchor">#</a> 如何使用</h2> <p>vue官方提供Vue-Router 这个插件来帮我们解决路由的问题，支持 hash、history、abstract 3 种路由方式，提供了 router-link 和 router-view 2 种组件，还提供了简单的路由配置和一系列好用的 API。</p> <p>Vue 提供了 Vue.use 的全局 API 来注册这些插件，定义在 vue/src/core/global-api/use.js ：</p> <div class="language- extra-class"><pre class="language-text"><code>export function initUse (Vue: GlobalAPI) {
  Vue.use = function (plugin: Function | Object) {
    const installedPlugins = (this._installedPlugins || (this._installedPlugins = []))
    if (installedPlugins.indexOf(plugin) &gt; -1) {
      return this
    }

    const args = toArray(arguments, 1)
    args.unshift(this)
    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args)
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args)
    }
    installedPlugins.push(plugin)
    return this
  }
}
</code></pre></div><p>Vue.use 接受一个 plugin 参数，并且维护了一个 _installedPlugins 数组，它存储所有注册过的 plugin；接着又会判断 plugin 有没有定义 install 方法，如果有的话则调用该方法，并且该方法执行的第一个参数是 Vue；最后把 plugin 存储到 installedPlugins 中。</p> <p>每个插件都需要实现一个静态的 install 方法，当我们执行 Vue.use 注册插件的时候，就会执行这个 install 方法，并且在这个 install 方法的第一个参数我们可以拿到 Vue 对象。</p> <h2 id="vue-router-的入口"><a href="#vue-router-的入口" aria-hidden="true" class="header-anchor">#</a> Vue-Router 的入口</h2> <p>入口在src/index.js，其中定义了 VueRouter 类，也实现了 install 的静态方法：VueRouter.install = install，定义在 src/install.js 中：</p> <div class="language- extra-class"><pre class="language-text"><code>xport let _Vue
export function install (Vue) {
  if (install.installed &amp;&amp; _Vue === Vue) return
  install.installed = true

  _Vue = Vue

  const isDef = v =&gt; v !== undefined

  const registerInstance = (vm, callVal) =&gt; {
    let i = vm.$options._parentVnode
    if (isDef(i) &amp;&amp; isDef(i = i.data) &amp;&amp; isDef(i = i.registerRouteInstance)) {
      i(vm, callVal)
    }
  }

  Vue.mixin({
    beforeCreate () {
      if (isDef(this.$options.router)) {
        this._routerRoot = this
        this._router = this.$options.router
        this._router.init(this)
        Vue.util.defineReactive(this, '_route', this._router.history.current)
      } else {
        this._routerRoot = (this.$parent &amp;&amp; this.$parent._routerRoot) || this
      }
      registerInstance(this, this)
    },
    destroyed () {
      registerInstance(this)
    }
  })

  Object.defineProperty(Vue.prototype, '$router', {
    get () { return this._routerRoot._router }
  })

  Object.defineProperty(Vue.prototype, '$route', {
    get () { return this._routerRoot._route }
  })

  Vue.component('RouterView', View)
  Vue.component('RouterLink', Link)

  const strats = Vue.config.optionMergeStrategies
  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created
}
</code></pre></div><p>当用户执行 Vue.use(VueRouter) 的时候，实际上就是在执行 install 函数，为了确保 install 逻辑只执行一次，用了 install.installed 变量做已安装的标志位。</p> <p>Vue-Router 安装最重要的一步就是利用 Vue.mixin 去把 beforeCreate 和 destroyed 钩子函数注入到每一个组件中。Vue.mixin 的定义，在 vue/src/core/global-api/mixin.js 中：</p> <div class="language- extra-class"><pre class="language-text"><code>export function initMixin (Vue: GlobalAPI) {
  Vue.mixin = function (mixin: Object) {
    this.options = mergeOptions(this.options, mixin)
    return this
  }
}
</code></pre></div><p>把要混入的对象通过 mergeOption 合并到 Vue 的 options 中，由于每个组件的构造函数都会在 extend 阶段合并 Vue.options 到自身的 options 中，所以也就相当于每个组件都定义了 mixin 定义的选项。</p> <p>回到 Vue-Router 的 install 方法，先看混入的 beforeCreate 钩子函数，对于根 Vue 实例而言，执行该钩子函数时定义了 this._routerRoot 表示它自身；this._router 表示 VueRouter 的实例 router，它是在 new Vue 的时候传入的；另外执行了 this._router.init() 方法初始化 router，这个逻辑之后介绍，然后用 defineReactive 方法把 this._route 变成响应式对象，这个作用我们之后会介绍。</p> <p>而对于子组件而言，由于组件是树状结构，在遍历组件树的过程中，它们在执行该钩子函数的时候 this._routerRoot 始终指向的是根 Vue 实例。</p> <p>接着给 Vue 原型上定义了 $router 和 $route 2 个属性的 get 方法，这就是为什么我们可以在组件实例上可以访问 this.$router 以及 this.$route。</p> <p>接着又通过 Vue.component 方法定义了全局的 router-link 和 router-view 2 个组件，最后定义了路由中的钩子函数的合并策略，和普通的钩子函数一样。</p> <p>总之，Vue-Router 的 install 方法会给每一个组件注入 beforeCreate 和 destoryed 钩子函数，在 beforeCreate 做一些私有属性定义和路由初始化工作。</p> <h2 id="vuerouter-对象"><a href="#vuerouter-对象" aria-hidden="true" class="header-anchor">#</a> VueRouter 对象</h2> <p>VueRouter 的实现是一个类，我们先对它做一个简单地分析，它的定义在 src/index.js 中：</p> <div class="language- extra-class"><pre class="language-text"><code>export default class VueRouter {
  static install: () =&gt; void;
  static version: string;

  app: any;
  apps: Array&lt;any&gt;;
  ready: boolean;
  readyCbs: Array&lt;Function&gt;;
  options: RouterOptions;
  mode: string;
  history: HashHistory | HTML5History | AbstractHistory;
  matcher: Matcher;
  fallback: boolean;
  beforeHooks: Array&lt;?NavigationGuard&gt;;
  resolveHooks: Array&lt;?NavigationGuard&gt;;
  afterHooks: Array&lt;?AfterNavigationHook&gt;;

  constructor (options: RouterOptions = {}) {
    this.app = null
    this.apps = []
    this.options = options
    this.beforeHooks = []
    this.resolveHooks = []
    this.afterHooks = []
    this.matcher = createMatcher(options.routes || [], this)

    let mode = options.mode || 'hash'
    this.fallback = mode === 'history' &amp;&amp; !supportsPushState &amp;&amp; options.fallback !== false
    if (this.fallback) {
      mode = 'hash'
    }
    if (!inBrowser) {
      mode = 'abstract'
    }
    this.mode = mode

    switch (mode) {
      case 'history':
        this.history = new HTML5History(this, options.base)
        break
      case 'hash':
        this.history = new HashHistory(this, options.base, this.fallback)
        break
      case 'abstract':
        this.history = new AbstractHistory(this, options.base)
        break
      default:
        if (process.env.NODE_ENV !== 'production') {
          assert(false, `invalid mode: ${mode}`)
        }
    }
  }

  match (
    raw: RawLocation,
    current?: Route,
    redirectedFrom?: Location
  ): Route {
    return this.matcher.match(raw, current, redirectedFrom)
  }

  get currentRoute (): ?Route {
    return this.history &amp;&amp; this.history.current
  }

  init (app: any) {
    process.env.NODE_ENV !== 'production' &amp;&amp; assert(
      install.installed,
      `not installed. Make sure to call \`Vue.use(VueRouter)\` ` +
      `before creating root instance.`
    )

    this.apps.push(app)

    if (this.app) {
      return
    }

    this.app = app

    const history = this.history

    if (history instanceof HTML5History) {
      history.transitionTo(history.getCurrentLocation())
    } else if (history instanceof HashHistory) {
      const setupHashListener = () =&gt; {
        history.setupListeners()
      }
      history.transitionTo(
        history.getCurrentLocation(),
        setupHashListener,
        setupHashListener
      )
    }

    history.listen(route =&gt; {
      this.apps.forEach((app) =&gt; {
        app._route = route
      })
    })
  }

  beforeEach (fn: Function): Function {
    return registerHook(this.beforeHooks, fn)
  }

  beforeResolve (fn: Function): Function {
    return registerHook(this.resolveHooks, fn)
  }

  afterEach (fn: Function): Function {
    return registerHook(this.afterHooks, fn)
  }

  onReady (cb: Function, errorCb?: Function) {
    this.history.onReady(cb, errorCb)
  }

  onError (errorCb: Function) {
    this.history.onError(errorCb)
  }

  push (location: RawLocation, onComplete?: Function, onAbort?: Function) {
    this.history.push(location, onComplete, onAbort)
  }

  replace (location: RawLocation, onComplete?: Function, onAbort?: Function) {
    this.history.replace(location, onComplete, onAbort)
  }

  go (n: number) {
    this.history.go(n)
  }

  back () {
    this.go(-1)
  }

  forward () {
    this.go(1)
  }

  getMatchedComponents (to?: RawLocation | Route): Array&lt;any&gt; {
    const route: any = to
      ? to.matched
        ? to
        : this.resolve(to).route
      : this.currentRoute
    if (!route) {
      return []
    }
    return [].concat.apply([], route.matched.map(m =&gt; {
      return Object.keys(m.components).map(key =&gt; {
        return m.components[key]
      })
    }))
  }

  resolve (
    to: RawLocation,
    current?: Route,
    append?: boolean
  ): {
    location: Location,
    route: Route,
    href: string,
    normalizedTo: Location,
    resolved: Route
  } {
    const location = normalizeLocation(
      to,
      current || this.history.current,
      append,
      this
    )
    const route = this.match(location, current)
    const fullPath = route.redirectedFrom || route.fullPath
    const base = this.history.base
    const href = createHref(base, fullPath, this.mode)
    return {
      location,
      route,
      href,
      normalizedTo: location,
      resolved: route
    }
  }

  addRoutes (routes: Array&lt;RouteConfig&gt;) {
    this.matcher.addRoutes(routes)
    if (this.history.current !== START) {
      this.history.transitionTo(this.history.getCurrentLocation())
    }
  }
}
VueRouter 定义了一些属性和方法，我们先从它的构造函数看，当我们执行 new VueRouter 的时候做了哪些事情。

constructor (options: RouterOptions = {}) {
  this.app = null
  this.apps = []
  this.options = options
  this.beforeHooks = []
  this.resolveHooks = []
  this.afterHooks = []
  this.matcher = createMatcher(options.routes || [], this)

  let mode = options.mode || 'hash'
  this.fallback = mode === 'history' &amp;&amp; !supportsPushState &amp;&amp; options.fallback !== false
  if (this.fallback) {
    mode = 'hash'
  }
  if (!inBrowser) {
    mode = 'abstract'
  }
  this.mode = mode

  switch (mode) {
    case 'history':
      this.history = new HTML5History(this, options.base)
      break
    case 'hash':
      this.history = new HashHistory(this, options.base, this.fallback)
      break
    case 'abstract':
      this.history = new AbstractHistory(this, options.base)
      break
    default:
      if (process.env.NODE_ENV !== 'production') {
        assert(false, `invalid mode: ${mode}`)
      }
  }
}
</code></pre></div><p>构造函数定义了一些属性，其中 this.app 表示根 Vue 实例，this.apps 保存持有 $options.router 属性的 Vue 实例，this.options 保存传入的路由配置，this.beforeHooks、 this.resolveHooks、this.afterHooks 表示一些钩子函数，this.matcher 表示路由匹配器，this.fallback 表示在浏览器不支持 history.pushState 的情况下，根据传入的 fallback 配置参数，决定是否回退到hash模式，this.mode 表示路由创建的模式，this.history 表示路由历史的具体的实现实例，它是根据 this.mode 的不同实现不同，它有 History 基类，然后不同的 history 实现都是继承 History。</p> <p>在组件的初始化阶段，执行到 beforeCreate 钩子函数的时候会执行 router.init 方法，然后又会执行 history.transitionTo 方法做路由过渡。实例化 VueRouter 后会返回它的实例 router，我们在 new Vue 的时候会把 router 作为配置的属性传入：</p> <div class="language- extra-class"><pre class="language-text"><code>beforeCreate() {
  if (isDef(this.$options.router)) {
    // ...
    this._router = this.$options.router
    this._router.init(this)
    // ...
  }
}  
</code></pre></div><p>所以组件在执行 beforeCreate 钩子函数的时候，如果传入了 router 实例，都会执行 router.init 方法：</p> <div class="language- extra-class"><pre class="language-text"><code>init (app: any) {
  process.env.NODE_ENV !== 'production' &amp;&amp; assert(
    install.installed,
    `not installed. Make sure to call \`Vue.use(VueRouter)\` ` +
    `before creating root instance.`
  )

  this.apps.push(app)

  if (this.app) {
    return
  }

  this.app = app

  const history = this.history

  if (history instanceof HTML5History) {
    history.transitionTo(history.getCurrentLocation())
  } else if (history instanceof HashHistory) {
    const setupHashListener = () =&gt; {
      history.setupListeners()
    }
    history.transitionTo(
      history.getCurrentLocation(),
      setupHashListener,
      setupHashListener
    )
  }

  history.listen(route =&gt; {
    this.apps.forEach((app) =&gt; {
      app._route = route
    })
  })
}
</code></pre></div><p>init 的逻辑很简单，它传入的参数是 Vue 实例，然后存储到 this.apps 中；只有根 Vue 实例会保存到 this.app 中，并且会拿到当前的 this.history，根据它的不同类型来执行不同逻辑。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/blog/fe/vue.html" class="prev">
          vue源码分析
        </a></span> <span class="next"><a href="/blog/fe/vuex.html">
          Vuex源码分析
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.63c679db.js" defer></script><script src="/blog/assets/js/2.2658334b.js" defer></script><script src="/blog/assets/js/6.d0a4dcb1.js" defer></script>
  </body>
</html>
